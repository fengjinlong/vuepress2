## 仿函数式组件
```
目标： fun.f([1,2,3])  fun([1,2,3]).f() 效果相同

单个方法
var fun = function (obj) {
      console.log(this)
      // 返回对象
      if (!(this instanceof fun)) return new fun(obj);
      // 缓存参数
      this._wrapped = obj;
    }
    // 静态方法
    // fun.f([1,2,3])
    fun.f = function (arr) {
      console.log(arr.reverse())
    }
    // 将静态方法挂在原型上
    fun.mixin = function (obj) {
      var func = fun.f
      // 原型方法
      fun.prototype.f = function () {
        var ob = [this._wrapped];
        ob.push(arguments)
        func.apply(fun, ob)
      }
      return fun
    }
    // 调用后等到原型方法
    fun.mixin(fun)

    // 调用原型方法
    fun([1,2,3]).f(function (arr) {
      console.log(arr.reverse())
    })

    全部方法
    var fun = function (obj) {
      console.log(this)
      // 返回对象
      if (!(this instanceof fun)) return new fun(obj);
      // 缓存参数
      this._wrapped = obj;
    }
    fun.each = function (obj, callback) {
      if (Array.isArray(obj)) {
        for (const item of obj) {
          callback && callback.call(_, item);
        }
      }
    }
    // 静态方法
    // fun.f([1,2,3])
    fun.f = function (arr) {
      console.log(arr.reverse())
    }
    // 将静态方法挂在原型上
    fun.mixin = function (obj) {
      //混合全部静态方法到原型链共享属性上
      fun.each(_.functions(obj), function (name) {
        var func = fun[name] = obj[name]
        fun.prototype[name] = function () {
          var args = [this._wrapped]
          args.push(arguments)
          func.apply(fun, args)
        }
      })
      return fun
    }
    // 调用后等到原型方法
    fun.mixin(fun)

    // 调用原型方法
    fun([1,2,3]).f()
```